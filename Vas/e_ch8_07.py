"""
 Напишите программу, в которой описана функция. В качестве аргументов функции передаются два объекта одного и того же класса.
У каждого объекта есть поле, представляющее собой список из целых
чисел. В результате функция возвращает объект того же класса. Поле список этого объекта получается суммированием соответствующих 
элементов из полей-списков объектов, переданных аргументами функции.
Если в этих объектах списки разной длины, то недостающие элементы в списке заменяются нулями.
"""
class A:
    def __init__(self, lst):
        self.lst = lst
a1 = A([2,3,5,6,3])
a2 = A([1,4,7,9,4, 12])
def sm_cl(a1,a2, A):
    # l1 = a1.lst
    # l2 = a2.lst
    l=[]
    lm = max(len(a1.lst),len(a2.lst))
    diflen = abs(len(a1.lst) - len(a2.lst))
    if len(a1.lst) < len(a2.lst):
        b2 = a2.lst
        b1 = a1.lst
        b1+= [0]*diflen
    else:
        b1 = a1.lst
        b2 = a2.lst
        b2+= [0]*diflen

    for i in range(lm):
        l.append(b1[i]+b2[i])
    # a = A(l)
    return A(l)        
print(vars(sm_cl(a1,a2,A)))
# -------------------------------------------  GPT


# a1 = A([2, 3, 5, 6, 3])
# a2 = A([1, 4, 7, 9, 4, 12])

def sm_clg(a1, a2):
    l1 = a1.lst
    l2 = a2.lst
    lm = max(len(a1.lst), len(a2.lst))
    diflen = abs(len(a1.lst) - len(a2.lst))

    if len(a1.lst) < len(a2.lst):
        b2 = a2.lst
        b1 = a1.lst
        b1 += [0] * diflen
    else:
        b1 = a1.lst
        b2 = a2.lst
        b2 += [0] * diflen

    l = [b1[i] + b2[i] for i in range(lm)]
    return A(l)

result = sm_clg(a1, a2)

# Выводим результат
print("GPT version:",result.lst)
"""
Если класс A объявлен внутри модуля (глобально), 
то он будет доступен для всех функций, объявленных в этом модуле без необходимости
 передавать класс A как параметр внутрь функций.
"""



